import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertChatHistorySchema, ChatMessage } from "@shared/schema";
import { randomUUID } from "crypto";
import {
  binanceClient,
  newsClient,
  sentimentClient,
  twitterClient,
  aiClient,
} from "./api-clients";
import { determineMessageIntent } from "./utils/message-intent";
import { callGeminiAPI, generateChatPrompt } from "./services/gemini-service";
import { generateMarketAnalysis } from "./services/market-analysis-service";
import { analyzeSentimentWithHuggingFace } from "./services/huggingface-service";

// Error handling interface and class
class CustomAPIError extends Error {
  code: string;
  statusCode: number;
  details?: any;

  constructor(message: string, statusCode = 500, code = 'INTERNAL_ERROR', details?: any) {
    super(message);
    this.name = 'CustomAPIError';
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
  }
}

// Global error handler middleware
function errorHandler(err: Error | CustomAPIError, req: Request, res: Response, next: NextFunction) {
  console.error('Error:', err);

  if (err instanceof CustomAPIError) {
    return res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.message,
        code: err.code,
        details: err.details
      }
    });
  }

  // Handle unknown errors
  return res.status(500).json({
    success: false,
    error: {
      message: 'An unexpected error occurred',
      code: 'INTERNAL_ERROR',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    }
  });
}

// Async route handler wrapper
const asyncHandler = (fn: Function) => (req: Request, res: Response, next: NextFunction) => {
  return Promise.resolve(fn(req, res, next)).catch(next);
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Market data routes
  app.get("/api/market", asyncHandler(async (req, res) => {
    console.log("Fetching real market data from Binance...");

    // Function to fetch with timeout and retry
    const fetchWithRetry = async (
      fn: () => Promise<any>,
      name: string,
      maxAttempts = 3
    ) => {
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          const result = await Promise.race([
            fn(),
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error(`${name} timeout`)), 5000)
            ),
          ]);
          return result;
        } catch (error) {
          if (attempt === maxAttempts) throw error;
          console.warn(`${name} attempt ${attempt} failed, retrying...`);
          await new Promise((resolve) => setTimeout(resolve, 1000 * attempt));
        }
      }
    };

    try {
      // Fetch real data from Binance API with retries
      const [realMarketData, realMarketStats] = await Promise.all([
        fetchWithRetry(
          () => binanceClient.getTopCryptocurrencies(),
          "Binance market data"
        ),
        fetchWithRetry(
          () => binanceClient.getMarketStats(),
          "Binance market stats"
        ),
      ]);

      if (realMarketData && realMarketData.length > 0) {
        res.json({
          success: true,
          data: {
            coins: realMarketData,
            stats: realMarketStats,
            dataSource: "Real-time market data",
            lastUpdated: new Date().toISOString(),
          },
        });
      } else {
        throw new CustomAPIError(
          "No market data available",
          503,
          "NO_MARKET_DATA"
        );
      }
    } catch (error) {
      console.error("Market data error:", error);

      // Try to provide fallback data
      try {
        const fallbackData = await storage.getMarketData();
        const fallbackStats = await storage.getMarketStats();

        res.json({
          success: true,
          data: {
            coins: fallbackData,
            stats: fallbackStats,
            dataSource: "Fallback data",
            lastUpdated: new Date().toISOString(),
          },
          warning: "Using cached data due to API connectivity issues",
        });
      } catch (fallbackError) {
        throw new CustomAPIError(
          "Failed to fetch market data",
          503,
          "MARKET_DATA_UNAVAILABLE",
          {
            originalError: error instanceof Error ? error.message : "Unknown error",
            suggestion: "Try again later or check your connection"
          }
        );
      }
    }
  }));

  // Detailed market data for a specific symbol
  interface Candle {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
  }

  interface MarketIndicators {
    rsi: number;
    sma20: number;
    priceChange24h: number;
    volumeChange24h: number;
  }

  app.get("/api/market/data", asyncHandler(async (req, res) => {
    const { symbol, interval, limit } = req.query;

    if (!symbol || !interval) {
      throw new CustomAPIError(
        "Missing required parameters",
        400,
        "INVALID_REQUEST",
        { required: ['symbol', 'interval'] }
      );
    }

    try {
      // Fetch and transform market data
      const candleData = await fetchBinanceData(symbol as string, interval as string, limit as string);
      const candles = transformCandleData(candleData);
      const indicators = calculateIndicators(candles);

      res.json({
        success: true,
        data: {
          symbol: symbol as string,
          interval: interval as string,
          candles,
          indicators,
          lastUpdated: new Date().toISOString(),
        },
      });
    } catch (error) {
      console.error("Market data error:", error);

      // Try to provide fallback data
      try {
        const fallbackData = await storage.getMarketData();
        const coinData = fallbackData.find(
          (coin) => coin.symbol.toLowerCase() === (symbol as string).toLowerCase()
        );

        if (!coinData) {
          throw new CustomAPIError(
            "No data available for the requested symbol",
            404,
            "SYMBOL_NOT_FOUND"
          );
        }

        res.json({
          success: true,
          data: {
            symbol: coinData.symbol,
            interval: interval as string,
            candles: [], // Empty candles for fallback
            indicators: {
              rsi: 50, // Neutral RSI
              sma20: parseFloat(coinData.price),
              priceChange24h: parseFloat(coinData.priceChangePercent24h),
              volumeChange24h: 0,
            },
            lastUpdated: new Date().toISOString(),
            dataSource: "fallback",
          },
          warning: "Using fallback data due to API connectivity issues",
        });
      } catch (fallbackError) {
        if (fallbackError instanceof CustomAPIError) {
          throw fallbackError;
        }
        throw new CustomAPIError(
          "Failed to fetch market data",
          503,
          "MARKET_DATA_UNAVAILABLE",
          {
            originalError: error instanceof Error ? error.message : "Unknown error",
            suggestion: "Try again later or check your connection"
          }
        );
      }
    }
  }));

  // News routes
  app.get("/api/news", asyncHandler(async (req, res) => {
    try {
      console.log("Fetching real news data from News API...");
      const newsArticles = await newsClient.getCryptoNews();

      // Analyze sentiment for the news articles
      console.log("Analyzing sentiment with AI...");
      const sentiment = await sentimentClient.calculateOverallSentiment(
        newsArticles
      );

      // Add sentiment to individual articles
      const articles = await Promise.all(
        newsArticles.slice(0, 8).map(async (article) => {
          const articleSentiment = await sentimentClient.analyzeSentiment(
            article.title
          );
          return {
            id: randomUUID(),
            ...article,
            sentiment: articleSentiment,
            createdAt: new Date(),
          };
        })
      );

      res.json({
        success: true,
        data: {
          articles,
          sentiment,
        },
      });
    } catch (error) {
      console.warn("News API failed, falling back to stored data:", error);
      
      try {
        const articles = await storage.getNewsArticles();
        const sentiment = await storage.getSentimentData();

        if (!articles.length) {
          throw new CustomAPIError(
            "No news data available",
            503,
            "NO_NEWS_DATA"
          );
        }

        res.json({
          success: true,
          data: {
            articles,
            sentiment,
            source: "fallback"
          },
        });
      } catch (fallbackError) {
        throw new CustomAPIError(
          "Failed to fetch news data",
          503,
          "NEWS_UNAVAILABLE",
          {
            originalError: error instanceof Error ? error.message : "Unknown error",
            suggestion: "Try again later or check your connection"
          }
        );
      }
    }
  }));

  // Chat routes
  app.post("/api/chat", asyncHandler(async (req, res) => {
    const { message: chatMessage, conversationId: chatConversationId } = req.body;

    if (!chatMessage || typeof chatMessage !== "string") {
      throw new CustomAPIError(
        "Message is required",
        400,
        "INVALID_REQUEST",
        { required: ['message'] }
      );
    }

    try {
      console.log("Generating AI response with market context...");

      // Fetch market context
      let marketContext;
      try {
        const [marketData, marketStats] = await Promise.all([
          binanceClient.getTopCryptocurrencies(),
          binanceClient.getMarketStats(),
        ]);

        marketContext = {
          topCoin: marketData[0],
          stats: marketStats,
          coins: marketData.slice(0, 3),
        };
      } catch (contextError) {
        console.warn("Failed to fetch real-time market context:", contextError);
        const [coins, stats] = await Promise.all([
          storage.getMarketData(),
          storage.getMarketStats(),
        ]);
        marketContext = {
          topCoin: coins[0],
          stats,
          coins: coins.slice(0, 3),
        };
      }

      // Generate AI response
      const chatPrompt = generateChatPrompt(chatMessage, marketContext);
      const aiResponse = await callGeminiAPI(chatPrompt);

      // Create response
      const response: ChatMessage = {
        id: randomUUID(),
        role: "assistant",
        content: aiResponse,
        timestamp: new Date().toISOString(),
        intent: determineMessageIntent(chatMessage),
      };

      res.json({
        success: true,
        data: { message: response },
      });
    } catch (error) {
      throw new CustomAPIError(
        "Failed to generate response",
        503,
        "AI_RESPONSE_FAILED",
        {
          originalError: error instanceof Error ? error.message : "Unknown error",
          suggestion: "Try rephrasing your message"
        }
      );
    }
  }));

  // Register error handling middleware
  app.use(errorHandler);

  const httpServer = createServer(app);
  return httpServer;
}

// Helper functions
async function fetchBinanceData(
  symbol: string,
  interval: string,
  limit?: string,
  maxAttempts = 3
): Promise<any[]> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000);

      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${
        limit || 100
      }`;
      console.log(`Attempt ${attempt}: Fetching from ${url}`);

      const response = await fetch(url, {
        signal: controller.signal,
        headers: {
          "User-Agent": "Tradeable-App/1.0",
          Accept: "application/json",
        },
        keepalive: true,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Binance API HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      if (error.name === "AbortError") {
        console.warn(`Request timeout after 8 seconds (attempt ${attempt})`);
      }

      if (attempt < maxAttempts) {
        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
        console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms:`, error.message);
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }
  throw new Error("Max retry attempts reached");
}

function transformCandleData(candleData: any[]): Candle[] {
  return candleData.map((candle: any[]) => ({
    time: candle[0],
    open: parseFloat(candle[1]),
    high: parseFloat(candle[2]),
    low: parseFloat(candle[3]),
    close: parseFloat(candle[4]),
    volume: parseFloat(candle[5]),
  }));
}

function calculateIndicators(candles: Candle[]): MarketIndicators {
  const closes = candles.map(c => c.close);
  const volumes = candles.map(c => c.volume);
  const rsi = calculateRSI(closes);
  const sma20 = calculateSMA(closes, 20);
  
  return {
    rsi: rsi[rsi.length - 1],
    sma20: sma20[sma20.length - 1],
    priceChange24h: ((closes[closes.length - 1] - closes[0]) / closes[0]) * 100,
    volumeChange24h: ((volumes[volumes.length - 1] - volumes[0]) / volumes[0]) * 100,
  };
}

function calculateSMA(prices: number[], period: number): number[] {
  const sma: number[] = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      sma.push(prices[i]);
      continue;
    }
    const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
    sma.push(sum / period);
  }
  return sma;
}

function calculateRSI(prices: number[], period: number = 14): number[] {
  if (prices.length < period + 1) {
    return new Array(prices.length).fill(50);
  }

  const gains: number[] = [];
  const losses: number[] = [];

  for (let i = 1; i < prices.length; i++) {
    const difference = prices[i] - prices[i - 1];
    gains.push(difference > 0 ? difference : 0);
    losses.push(difference < 0 ? -difference : 0);
  }

  const rsi: number[] = [];
  let avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;
  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;

  rsi.push(100 - 100 / (1 + avgGain / avgLoss));

  for (let i = period; i < gains.length; i++) {
    avgGain = (avgGain * (period - 1) + gains[i]) / period;
    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;

    if (avgLoss === 0) {
      rsi.push(100);
    } else {
      rsi.push(100 - 100 / (1 + avgGain / avgLoss));
    }
  }

  return [...new Array(period).fill(50), ...rsi];
}
