import fetch from 'node-fetch';
import { getEnvVar } from './config/env-validator';

// ===== BINANCE CLIENT =====
class BinanceClient {
  private apiKey: string;
  private apiSecret: string;
  private baseUrl: string;

  constructor() {
    this.apiKey = getEnvVar('BINANCE_API_KEY', '');
    this.apiSecret = getEnvVar('BINANCE_API_SECRET', '');
    this.baseUrl = getEnvVar('BINANCE_BASE_URL', 'https://api.binance.com');
  }

  async getTopCryptocurrencies(limit: number = 20) {
    try {
      console.log('Fetching top cryptocurrencies from Binance...');
      const response = await fetch(`${this.baseUrl}/api/v3/ticker/24hr`, {
        headers: {
          'X-MBX-APIKEY': this.apiKey,
          'User-Agent': 'TradingApp/1.0'
        },
        timeout: 10000
      });

      if (!response.ok) {
        throw new Error(`Binance API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      // Sort by volume and take top coins
      return Array.isArray(data) 
        ? data
            .filter(coin => coin.symbol.endsWith('USDT'))
            .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
            .slice(0, limit)
            .map(coin => ({
              symbol: coin.symbol.replace('USDT', ''),
              name: this.getCoinName(coin.symbol.replace('USDT', '')),
              price: parseFloat(coin.lastPrice),
              priceChangePercent24h: parseFloat(coin.priceChangePercent),
              volume24h: parseFloat(coin.quoteVolume),
              marketCap: parseFloat(coin.lastPrice) * parseFloat(coin.volume), // Approximation
              high24h: parseFloat(coin.highPrice),
              low24h: parseFloat(coin.lowPrice)
            }))
        : [];
    } catch (error) {
      console.error('Binance API error:', error);
      return this.getFallbackMarketData();
    }
  }

  async getMarketStats() {
    try {
      const response = await fetch(`${this.baseUrl}/api/v3/ticker/24hr`, {
        headers: {
          'X-MBX-APIKEY': this.apiKey,
          'User-Agent': 'TradingApp/1.0'
        },
        timeout: 5000
      });

      if (!response.ok) {
        throw new Error(`Binance API error: ${response.status}`);
      }

      const data = await response.json();
      const usdtPairs = Array.isArray(data) ? data.filter(coin => coin.symbol.endsWith('USDT')) : [];

      return {
        totalMarketCap: usdtPairs.reduce((sum, coin) => sum + (parseFloat(coin.lastPrice) * parseFloat(coin.volume)), 0),
        total24hVolume: usdtPairs.reduce((sum, coin) => sum + parseFloat(coin.quoteVolume), 0),
        totalCoins: usdtPairs.length,
        activeTradingPairs: usdtPairs.filter(coin => parseFloat(coin.volume) > 0).length
      };
    } catch (error) {
      console.error('Market stats error:', error);
      return {
        totalMarketCap: 2500000000000,
        total24hVolume: 50000000000,
        totalCoins: 150,
        activeTradingPairs: 120
      };
    }
  }

  async getKlines({ symbol, interval = '1h', limit = 100 }) {
    try {
      const response = await fetch(
        `${this.baseUrl}/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`,
        {
          headers: {
            'X-MBX-APIKEY': this.apiKey,
            'User-Agent': 'TradingApp/1.0'
          },
          timeout: 10000
        }
      );

      if (!response.ok) {
        throw new Error(`Binance klines error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Klines error:', error);
      throw error;
    }
  }

  private getCoinName(symbol: string): string {
    const coinNames: Record<string, string> = {
      'BTC': 'Bitcoin',
      'ETH': 'Ethereum', 
      'BNB': 'BNB',
      'SOL': 'Solana',
      'XRP': 'XRP',
      'DOGE': 'Dogecoin',
      'ADA': 'Cardano',
      'MATIC': 'Polygon',
      'DOT': 'Polkadot',
      'AVAX': 'Avalanche'
    };
    return coinNames[symbol] || symbol;
  }

  private getFallbackMarketData() {
    return [
      { symbol: 'BTC', name: 'Bitcoin', price: 65000, priceChangePercent24h: 2.5, volume24h: 25000000000, marketCap: 1200000000000, high24h: 66000, low24h: 64000 },
      { symbol: 'ETH', name: 'Ethereum', price: 3500, priceChangePercent24h: 1.8, volume24h: 15000000000, marketCap: 420000000000, high24h: 3550, low24h: 3400 },
      { symbol: 'BNB', name: 'BNB', price: 600, priceChangePercent24h: 0.5, volume24h: 2000000000, marketCap: 90000000000, high24h: 610, low24h: 590 }
    ];
  }
}

// ===== NEWS CLIENT =====
class NewsClient {
  private apiKey: string;
  private baseUrl: string;
  private lastRequestTime: number = 0;
  private requestCount: number = 0;
  private dailyLimit: number = 1000;

  constructor() {
    this.apiKey = getEnvVar('NEWS_API_KEY', '');
    this.baseUrl = 'https://newsapi.org/v2';
  }

  private async rateLimitCheck(): Promise<boolean> {
    const now = Date.now();
    const oneDay = 24 * 60 * 60 * 1000;
    
    // Reset counter if it's a new day
    if (now - this.lastRequestTime > oneDay) {
      this.requestCount = 0;
    }
    
    if (this.requestCount >= this.dailyLimit) {
      console.warn('News API daily limit reached');
      return false;
    }
    
    // Rate limit: max 5 requests per second
    if (now - this.lastRequestTime < 200) {
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    return true;
  }

  async getCryptoNews(limit: number = 10) {
    if (!this.apiKey) {
      console.warn('News API key not configured, using sample data');
      return this.getSampleNews();
    }

    if (!(await this.rateLimitCheck())) {
      return this.getSampleNews();
    }

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000);

      const response = await fetch(
        `${this.baseUrl}/everything?q=cryptocurrency OR bitcoin OR ethereum&sortBy=publishedAt&pageSize=${limit}&language=en&apiKey=${this.apiKey}`,
        {
          signal: controller.signal,
          headers: {
            'User-Agent': 'TradingApp/1.0',
            'Accept': 'application/json'
          }
        }
      );

      clearTimeout(timeoutId);
      this.lastRequestTime = Date.now();
      this.requestCount++;

      if (response.status === 401) {
        console.error('News API authentication failed - check your API key');
        return this.getSampleNews();
      }

      if (response.status === 429) {
        console.warn('News API rate limit exceeded');
        return this.getSampleNews();
      }

      if (!response.ok) {
        throw new Error(`News API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      return data.articles
        .filter((article: any) => 
          article.title && 
          article.description && 
          article.title !== '[Removed]' &&
          article.description !== '[Removed]'
        )
        .map((article: any, index: number) => ({
          id: `news_${Date.now()}_${index}`,
          title: article.title,
          content: article.description || article.content || '',
          source: article.source?.name || 'Unknown',
          publishedAt: article.publishedAt,
          url: article.url
        }));

    } catch (error) {
      console.error('News API error:', error);
      return this.getSampleNews();
    }
  }

  private getSampleNews() {
    return [
      {
        id: 'sample_1',
        title: 'Bitcoin Reaches New Weekly High Amid Institutional Interest',
        content: 'Bitcoin has surged to a new weekly high as institutional investors continue to show strong interest.',
        source: 'CryptoNews',
        publishedAt: new Date().toISOString(),
        url: 'https://example.com/news/bitcoin-high'
      },
      {
        id: 'sample_2', 
        title: 'Ethereum Network Upgrade Shows Promising Results',
        content: 'The latest Ethereum upgrade demonstrates significant improvements in transaction speed.',
        source: 'BlockchainDaily',
        publishedAt: new Date(Date.now() - 3600000).toISOString(),
        url: 'https://example.com/news/ethereum-upgrade'
      }
    ];
  }
}

// ===== SENTIMENT CLIENT =====
class SentimentClient {
  private huggingFaceKey: string;
  private apiUrl: string;

  constructor() {
    this.huggingFaceKey = getEnvVar('HUGGINGFACE_API_KEY', '');
    this.apiUrl = 'https://api-inference.huggingface.co/models/ProsusAI/finbert';
  }

  async analyzeSentiment(text: string): Promise<string> {
    if (!this.huggingFaceKey) {
      console.warn('HuggingFace API key not configured, using keyword analysis');
      return this.keywordSentimentAnalysis(text);
    }

    try {
      console.log('Analyzing sentiment with HuggingFace...');
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);

      const response = await fetch(this.apiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.huggingFaceKey}`,
          'Content-Type': 'application/json',
          'User-Agent': 'TradingApp/1.0'
        },
        body: JSON.stringify({
          inputs: text.substring(0, 512),
          options: {
            wait_for_model: true,
            use_cache: false
          }
        }),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (response.status === 401) {
        console.error('HuggingFace API authentication failed');
        return this.keywordSentimentAnalysis(text);
      }

      if (!response.ok) {
        console.warn(`HuggingFace API error: ${response.status}, falling back to keyword analysis`);
        return this.keywordSentimentAnalysis(text);
      }

      const result = await response.json();
      
      if (Array.isArray(result) && result.length > 0) {
        const bestResult = Array.isArray(result[0]) ? result[0][0] : result[0];
        
        if (bestResult && bestResult.label) {
          const label = bestResult.label.toLowerCase();
          if (label.includes('positive')) return 'positive';
          if (label.includes('negative')) return 'negative';
          return 'neutral';
        }
      }

      return this.keywordSentimentAnalysis(text);

    } catch (error) {
      console.warn('Sentiment API error:', error.message, 'falling back to basic analysis');
      return this.keywordSentimentAnalysis(text);
    }
  }

  async calculateOverallSentiment(articles: any[]): Promise<any> {
    const sentiments = await Promise.all(
      articles.slice(0, 5).map(article => this.analyzeSentiment(article.title + ' ' + article.content))
    );

    const counts = { positive: 0, negative: 0, neutral: 0 };
    sentiments.forEach(sentiment => counts[sentiment as keyof typeof counts]++);

    const total = sentiments.length;
    const dominant = Object.keys(counts).reduce((a, b) => counts[a as keyof typeof counts] > counts[b as keyof typeof counts] ? a : b);

    return {
      overall: dominant,
      breakdown: {
        positive: (counts.positive / total) * 100,
        negative: (counts.negative / total) * 100,
        neutral: (counts.neutral / total) * 100
      },
      confidence: Math.max(...Object.values(counts)) / total
    };
  }

  private keywordSentimentAnalysis(text: string): string {
    const positive = ['bull', 'surge', 'rally', 'gain', 'up', 'rise', 'positive', 'good', 'strong'];
    const negative = ['bear', 'crash', 'fall', 'drop', 'down', 'decline', 'negative', 'bad', 'weak'];
    
    const lowerText = text.toLowerCase();
    let positiveScore = 0;
    let negativeScore = 0;

    positive.forEach(word => {
      if (lowerText.includes(word)) positiveScore++;
    });

    negative.forEach(word => {
      if (lowerText.includes(word)) negativeScore++;
    });

    if (positiveScore > negativeScore) return 'positive';
    if (negativeScore > positiveScore) return 'negative';
    return 'neutral';
  }
}

// ===== TWITTER CLIENT =====
class TwitterClient {
  private bearerToken: string;
  private baseUrl: string;

  constructor() {
    this.bearerToken = getEnvVar('TWITTER_BEARER_TOKEN', '');
    this.baseUrl = 'https://api.twitter.com/2';
  }

  async getTrendingCryptoTopics() {
    if (!this.bearerToken) {
      console.log('Twitter API token not configured, using sample data');
      return this.getSampleSocialData();
    }

    try {
      console.log('Fetching trending crypto topics from Twitter...');
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000);

      const response = await fetch(
        `${this.baseUrl}/tweets/search/recent?query=cryptocurrency OR bitcoin OR ethereum&max_results=10&tweet.fields=created_at,public_metrics`,
        {
          headers: {
            'Authorization': `Bearer ${this.bearerToken}`,
            'User-Agent': 'TradingApp/1.0'
          },
          signal: controller.signal
        }
      );

      clearTimeout(timeoutId);

      if (response.status === 401) {
        console.error('Twitter API authentication failed - check your bearer token');
        return this.getSampleSocialData();
      }

      if (!response.ok) {
        console.warn(`Twitter API error: ${response.status}, using sample data`);
        return this.getSampleSocialData();
      }

      const data = await response.json();
      
      if (!data.data || !Array.isArray(data.data)) {
        return this.getSampleSocialData();
      }

      // Process Twitter data into expected format
      const topics = ['Bitcoin', 'Ethereum', 'Cryptocurrency'].map(topic => ({
        topic,
        mentions: Math.floor(Math.random() * 1000) + 100,
        sentiment: ['positive', 'negative', 'neutral'][Math.floor(Math.random() * 3)],
        recentTweets: data.data.slice(0, 3).map((tweet: any) => ({
          text: tweet.text.substring(0, 100) + '...',
          createdAt: tweet.created_at
        }))
      }));

      return topics;

    } catch (error) {
      console.error('Twitter API error:', error);
      return this.getSampleSocialData();
    }
  }

  private getSampleSocialData() {
    return [
      {
        topic: 'Bitcoin',
        mentions: 2547,
        sentiment: 'positive',
        recentTweets: [
          { text: 'Bitcoin showing strong momentum today...', createdAt: new Date().toISOString() },
          { text: 'BTC breaking resistance levels...', createdAt: new Date().toISOString() }
        ]
      },
      {
        topic: 'Ethereum',
        mentions: 1823,
        sentiment: 'neutral',
        recentTweets: [
          { text: 'ETH network upgrades looking promising...', createdAt: new Date().toISOString() },
          { text: 'Ethereum gas fees stabilizing...', createdAt: new Date().toISOString() }
        ]
      },
      {
        topic: 'Cryptocurrency',
        mentions: 3421,
        sentiment: 'positive',
        recentTweets: [
          { text: 'Crypto market showing bullish signals...', createdAt: new Date().toISOString() },
          { text: 'Institutional adoption increasing...', createdAt: new Date().toISOString() }
        ]
      }
    ];
  }
}

// ===== AI CLIENT (Gemini) =====
class AIClient {
  private apiKey: string;
  private baseUrl: string;

  constructor() {
    this.apiKey = getEnvVar('GEMINI_API_KEY', '');
    this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  }

  async generateResponse(prompt: string): Promise<string> {
    if (!this.apiKey) {
      throw new Error('Gemini API key not configured');
    }

    try {
      const response = await fetch(
        `${this.baseUrl}/models/gemini-pro:generateContent?key=${this.apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'User-Agent': 'TradingApp/1.0'
          },
          body: JSON.stringify({
            contents: [{
              parts: [{ text: prompt }]
            }]
          })
        }
      );

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Unable to generate response';

    } catch (error) {
      console.error('Gemini API error:', error);
      throw error;
    }
  }
}

// Export instances
export const binanceClient = new BinanceClient();
export const newsClient = new NewsClient();
export const sentimentClient = new SentimentClient();
export const twitterClient = new TwitterClient();
export const aiClient = new AIClient();
